---
title: 设计模式——装饰器模式
date: 2018-09-21 17:31:54
index_img: /img/indexImg/dm_decorator.png
categories: 设计模式
tags: 设计模式
---

# 设计模式——装饰器模式

2018-09-21

- [设计模式]()

1. **概述**

   最近在工作中接触到了有关装饰器模式的代码，所以想总结一下关于这方面的知识；

   比方说，快下班了，肚子咕噜咕噜的叫了，于是乎今天打算在楼下的97烧腊店解决晚餐；进到店里，菜单上写着叉烧饭、猪脚饭、鸡腿饭、鸭腿饭、肥肠饭、烧鹅饭、白切鸡饭……唏哩呼噜列了一大摞，菜式丰富对于顾客来说选择自然也就多，但是选择一多起来对于我这种选择困难症的人来说那就是一场不亚于我当初高考后是选清华还是北大的抉择（╮(￣▽￣)╭不过由于他们都不来联系我，我一气之下把他们拉进了黑名单），好在贴心的老板娘早就想到我们会纠结，热心的推出了双p,呸，是双拼，多拼的套餐，这也就意味着我可以吃叉烧拼猪脚饭或叉烧拼鸭腿，又或者是烧鹅拼白切鸡饭，当然你还可以选择巨无霸套餐之——叉烧拼猪脚拼鸡腿拼鸭腿拼肥肠拼烧鹅拼白切鸡饭！又名拼多多饭！！！（拼多多看到了请打广告费，谢谢）

   假设要把这样的一个饭店卖烧腊饭的流程用代码实现的话，那么你得首先定义一个烧腊饭的基类Rice，其中定义其基本的方法，比如描述和价格等，而所有种类的烧腊饭将会继承这个基类，并且覆盖这些方法；那么如果你把那些双拼多拼的任意组合都写上去的话，你起码得写上百个子类，这种方式显然不符合软件工程里所推崇的“多用组合，少用继承”的原则；

   所以把上述的方法用一种更加富有弹性的方案来替代，那就是采用装饰器模式来实现；

2. **思想**

   装饰器模式中，有四大块，分别是:

   基类Component(组件)、基类实现类ConcreteComponent

   抽象装饰类Decorator（装饰）、装饰类实现类ConcreteDecorator

   其中，基类是最顶层的类也就是其它三个的父类，也就是祖宗类（滑稽.jpg），基类实现类和装饰类都是直接继承自基类Component,而我们所要实现的装饰类实现类就是我们的叉烧拼猪脚饭！！！（额…..md饿疯了吧）就是我们所要实现的不同组合；

   以下是装饰器模式的类图：

   ![img](https://ws1.sinaimg.cn/large/0062Zwz8gy1fvh0c9z0hrj30q70eumxt.jpg)

   图源：知乎——前端客栈

3. **实现**

   （1）定义我们的抽象基类Rice（也就是组件），其它的类都是它的子类or孙子类！！！（滑稽.jpg）

   ```java
   //定义我们的基类Rice
   public abstract class Rice{
       public abstract String getDescription();
   }
   ```

   （2）接下来定义我们的具体实现类烧腊饭ShaolaRice（组件的具体实现类）

   ```java
   public class extend ShaolaRice extends Rice{
       @Override
       public String getDescription(){
           return "饭";
       }
   }
   ```

   （3）定义抽象装饰类——配菜基类

   ```java
   public abstract class Peicai extends Rice{
       //要添加一个基类的引用
       protected Rice rice;
       @Override
       public String getDescription(){
           return "";
       }
   }
   ```

   （4）定义装饰类实现类——配菜实现类

   ```java
   //叉烧
   public class Chashao extends Peicai{
       public Chashao(Rice rice){
           this.rice = rice;
       }
       public String getDesciption(){
           //这个判断只是为了在组合时多加个拼字
           if(rice.getDescription().length() > 2){
               return "叉烧拼"+rice.getDescription();
           }
           return "叉烧"+rice.getDescription();
       }
   }
   //烧鸭
   public class Shaoya extends Peicai{
       public Shaoya(Rice rice){
           this.rice = rice;
       }
       public String getDescription(){
           //这个判断只是为了在组合时多加个拼字
           if(rice.getDescription().length() > 2){
               return "烧鸭拼"+rice.getDescription();
           }
           return "烧鸭"+rice.getDescription();
       }
   }
   //烧鸡
   public class Shaoji extends Peicai{
       public Shaoji(Rice rice){
           this.rice = rice;
       }
       public String getDescription(){
           //这个判断只是为了在组合时多加个拼字
           if(rice.getDescription().length() > 2){
               return "烧鸡拼"+rice.getDescription();
           }
           return "烧鸡"+rice.getDescription();
       }
   }
   //肥肠
   public class Feichang extends Peicai{
       public Feichang(Rice rice){
           this.rice = rice;
       }
       public String getDescription(){
           //这个判断只是为了在组合时多加个拼字
           if(rice.getDescription().length() > 2){
               return "肥肠拼"+rice.getDescription();
           }
           return "肥肠"+rice.getDescription();
       }
   }
   //猪脚
   public class Zhujiao extends Peicai{
       public Zhujiao(Rice rice){
           this.rice = rice;
       }
       public String getDescription(){
           //这个判断只是为了在组合时多加个拼字
           if(rice.getDescription().length() > 2){
               return "猪脚拼"+rice.getDescription();
           }
           return "猪脚"+rice.getDescription();
       }
   }
   剩下的那些........你懂我意思吧？.jpg
   ```

   (5）万事具备，只差筷子了！

   ```java
   //测试（开吃！！！）
   public class TestEat {
       public static void main(String[] args) {
           //老板娘，我要叉烧拼猪脚饭！
           Rice shaolaRice = new ShaolaRice();
           //给饭上加配菜（装饰）
           //写法1
           //shaolaRice = new Zhujiao(shaolaRice);
           //shaolaRice = new Chashao(shaolaRice);
           //写法2：
           shaolaRice = new Chashao(new Zhujiao(shaolaRice));
   
           //拼多多套餐饭！
           Rice shaolaRice2 = new ShaolaRice();
           shaolaRice2 = new Chashao(new Zhujiao(new Shaoya(new Shaoji(new Feichang(shaolaRice2)))));
   
           System.out.println("哇！"+shaolaRice.getDescription()+"好好味啊！！！");
           System.out.println("哇！"+shaolaRice2.getDescription()+"好好味啊！！！");
   
       }
   }
   ```

   测试结果：

   ![img](https://ws1.sinaimg.cn/large/0062Zwz8gy1fvh7jwq1ahj30bm01waa4.jpg)

4. **总结**

   **优点：**

   - 装饰器模式的优点在于不用在程序尚未执行的时候就创建大量的类，取而代之的是在程序运行时根据需要动态的组合我们所需要的类；
   - 扩展性好，就如同上面的例子，哪天老板娘又发明出什么新菜色，像什么烧鹅，鸭腿，兔肉（兔兔那么可爱，你怎么能吃兔兔o(╥﹏╥)o.gif），这时候我们只需要继承装饰类基类，就能完成添加新菜色的任务啦~；

   **缺点：**

   - 不易调试，过多的使用装饰器模式会导致系统由许多类似的小的对象组成，会产生大量的装饰者类；
   - 肚子容易饿……下次举例子千万不要举吃东西的，不说了，写完我就去找老板娘了；

   **适用场景：**

   - 为独立的对象动态并透明的添加职责，意思是，不影响其它对象；
   - 处理能收回的职责；
   - 当不能通过子类来扩充时。有时候一大堆独立的扩充是可能的，但将激增子类来支持每种扩充间的组合。或者一个类的定义可能被隐藏或不能用于生成子类。

1. **应用**
   - Java中的IO流
   - Python中的装饰器语法
2. **引用**
   - [设计模式之装饰器模式——前端客栈（知乎）](https://zhuanlan.zhihu.com/p/25003369)
   - [[JAVA\]设计模式之装饰器模式](http://blog.qiji.tech/archives/11823)
   - [浅谈设计模式三: 装饰器模式(Decorator)](http://dreamrunner.org/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3/)
   - [Java：一夜一发设计模式（一）——装饰者模式](https://blog.csdn.net/android_zyf/article/details/68343953)
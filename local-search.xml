<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git命令操作大全</title>
    <link href="/2018/10/01/Git%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/"/>
    <url>/2018/10/01/Git%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<p>作者：[已重置]</p><p>链接：<a href="https://zhuanlan.zhihu.com/p/25868120" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25868120</a></p><p>来源：知乎</p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><pre><code class="shell"># 在当前目录新建一个 Git 代码库$ git init# 新建一个目录，将其初始化为 Git 代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><pre><code class="shell"># 显示当前的 Git 配置$ git config --list# 编辑 Git 配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><pre><code class="shell"># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><pre><code class="shell"># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次 commit 之后的变化，直接到仓库区$ git commit -a# 提交时显示所有 diff 信息$ git commit -v# 使用一次新的 commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息$ git commit --amend -m [message]# 重做上一次 commit，并包括指定文件的新变化$ git commit --amend   ...</code></pre><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><pre><code class="shell"># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定 commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个 commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete $ git branch -dr</code></pre><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><pre><code class="shell"># 列出所有 tag$ git tag# 新建一个 tag 在当前 commit$ git tag [tag]# 新建一个 tag 在指定 commit$ git tag [tag] [commit]# 查看 tag 信息$ git show [tag]# 提交指定 tag$ git push [remote] [tag]# 提交所有 tag$ git push [remote] --tags# 新建一个分支，指向某个 tag$ git checkout -b [branch] [tag]</code></pre><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><pre><code class="shell"># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示 commit 历史，以及每次 commit 发生变更的文件$ git log --stat# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次 diff$ git log -p [file]# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个 commit 的差异$ git diff --cached []# 显示工作区与当前分支最新 commit 之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><pre><code class="shell"># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><pre><code class="shell"># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个 commit 的指定文件到工作区$ git checkout [commit] [file]# 恢复上一个 commit 的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次 commit 保持一致$ git reset --hard# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致$ git reset --hard [commit]# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个 commit，用来撤销指定 commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]</code></pre><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><pre><code class="shell"># 生成一个可供发布的压缩包$ git archive</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具字典</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具字典</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——单例模式</title>
    <link href="/2018/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2018/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>单例类只能有一个实例；</p><p>单例类必须自己创建自己的唯一实例；</p><p>单例类必须给所有其他对象提供这一实例。</p><a id="more"></a><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。计算机系统中，线程池、日志对象、对话框、打印机、显卡的驱动程序对象被设计成单例。此类应用或多或少具有资源管理器的功能。</p><p>例如每台计算机可以有若干个打印机，但只能有一个Printer Spooler,以避免两个打印作业同时输出到打印机中，每台计算机可以由若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态。</p><h3 id="1-懒汉式单例"><a href="#1-懒汉式单例" class="headerlink" title="1.懒汉式单例"></a>1.懒汉式单例</h3><pre><code class="java">//在第一次调用的时候实例化自己public class Singleton(){    private Singleton(){}    private static Singleton single = null;    //静态工厂方法    public static Singleton getInstance(){        if(single == null){            single = new Singleton();        }        return single;    }}</code></pre><p>Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过 getInstance()方法访问。（其实可以通过java反射机制来实现实例化构造方法为private的类，但是那基本上会是所有的Java单例实现失效。）</p><p>上述实现懒汉式单例并诶呦考虑线程安全的问题，它是线程不安全的，并发条件下很可能会出现多个Singleton实例 。</p><p>以下为实现了线程安全的懒汉式单例模式</p><ol><li><p>在getInstance方法上加同步</p><pre><code class="java">public static synchronized Singleton getInstance(){    if(single == null){        single = new Singleton();    }    return single;}</code></pre></li><li><p>双重检查锁定</p><pre><code class="java">public static Singleton getInstancee(){    if(singleton == null){        synchronized(Singleton.class){            if(singleton == null){                singleton = new Singleton();            }        }    }    return singleton;}</code></pre></li><li><p>静态内部类</p><pre><code class="java">public class Singleton{    private static class LazyHolder{        private static final Singleton INSTANCE = new Singleton();    }    private Singleton(){}    public static final Singleton getInstance(){        return LazyHolder.INSTANCE;    }}//这种比1,2都要好一些，既实现了线程安全，有避免了同步带来的性能影响。</code></pre></li></ol><h3 id="2-饿汉式单例"><a href="#2-饿汉式单例" class="headerlink" title="2.饿汉式单例"></a>2.饿汉式单例</h3><pre><code class="java">//饿汉式单例，在类初始化时，已经自行实例化public class Singleton1(){    private Singleton1(){}    private static final Singleton1 single = new Singleton1();    //静态工厂方法    public static Singleton1 getInstance(){        return single;    }}</code></pre><h3 id="3-登记式单例（扩展）"><a href="#3-登记式单例（扩展）" class="headerlink" title="3.登记式单例（扩展）"></a>3.登记式单例（扩展）</h3><pre><code class="java">//类似Spring里面的方法，将类名注册，下次从里面直接获取。public class Singleton3 {    private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;();    static{        Singleton3 single = new Singleton3();        map.put(single.getClass().getName(), single);    }    //保护的默认构造子    protected Singleton3(){}    //静态工厂方法,返还此类惟一的实例    public static Singleton3 getInstance(String name) {        if(name == null) {            name = Singleton3.class.getName();            System.out.println(&quot;name == null&quot;+&quot;---&gt;name=&quot;+name);        }        if(map.get(name) == null) {            try {                map.put(name, (Singleton3) Class.forName(name).newInstance());            } catch (InstantiationException e) {                e.printStackTrace();            } catch (IllegalAccessException e) {                e.printStackTrace();            } catch (ClassNotFoundException e) {                e.printStackTrace();            }        }        return map.get(name);    }    //一个示意性的商业方法    public String about() {            return &quot;Hello, I am RegSingleton.&quot;;        }        public static void main(String[] args) {        Singleton3 single3 = Singleton3.getInstance(null);        System.out.println(single3.about());    }</code></pre><p>登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。</p><p>这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。</p><p><strong>饿汉式和懒汉式区别</strong></p><p>饿汉就是累一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了；</p><p>懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。</p><p>另外从以下两点再区分</p><ol><li><p>线程安全</p><p>饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题；</p><p>懒汉式本身是非线程安全的，为了实现线程安全就有了以上的三种写法。</p></li><li><p>资源加载和性能</p><p>饿汉式在类创建的时候就同时实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用的时候速度也会更快，因为其资源以及初始化完成；</p><p>而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能会有些延迟，之后就和懒汉式一样了。</p><p>懒汉式线程安全实现的三中方法中</p><p>第一种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的；</p><p>第二种，在getInstance中做了两次null检查，确保了 只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免每次都同步的性能损耗；</p><p>第三种，利用了classloader的机制来保证初始换instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。</p></li></ol><h3 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h3><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码，如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一眼的，那就是线程安全的；</p><p>或者说，一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题，那就是线程安全的。</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>以懒汉式为例，这里为了保证线程安全用了双重检查锁定方式</p><pre><code>public class TestSingleton {    String name = null;        private TestSingleton() {    }    private static volatile TestSingleton instance = null;    public static TestSingleton getInstance() {           if (instance == null) {               synchronized (TestSingleton.class) {                  if (instance == null) {                     instance = new TestSingleton();                 }               }             }            return instance;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public void printInfo() {        System.out.println(&quot;the name is &quot; + name);    }}public class TMain {    public static void main(String[] args){        TestStream ts1 = TestSingleton.getInstance();        ts1.setName(&quot;jason&quot;);        TestStream ts2 = TestSingleton.getInstance();        ts2.setName(&quot;0539&quot;);        ts1.printInfo();        ts2.printInfo();        if(ts1 == ts2){            System.out.println(&quot;创建的是同一个实例&quot;);        }else{            System.out.println(&quot;创建的不是同一个实例&quot;);        }    }}</code></pre><p>运行结果：</p><p>结论：由结果可以得知单例模式为一个面向对象的应用程序提供了对象唯一的访问点，不管它实现何种功能，整个应用程序都会同享一个实例对象。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——装饰器模式</title>
    <link href="/2018/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2018/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式——装饰器模式"><a href="#设计模式——装饰器模式" class="headerlink" title="设计模式——装饰器模式"></a>设计模式——装饰器模式</h1><p>2018-09-21</p><ul><li><a href="">设计模式</a></li></ul><ol><li><p><strong>概述</strong></p><p>最近在工作中接触到了有关装饰器模式的代码，所以想总结一下关于这方面的知识；</p><p>比方说，快下班了，肚子咕噜咕噜的叫了，于是乎今天打算在楼下的97烧腊店解决晚餐；进到店里，菜单上写着叉烧饭、猪脚饭、鸡腿饭、鸭腿饭、肥肠饭、烧鹅饭、白切鸡饭……唏哩呼噜列了一大摞，菜式丰富对于顾客来说选择自然也就多，但是选择一多起来对于我这种选择困难症的人来说那就是一场不亚于我当初高考后是选清华还是北大的抉择（╮(￣▽￣)╭不过由于他们都不来联系我，我一气之下把他们拉进了黑名单），好在贴心的老板娘早就想到我们会纠结，热心的推出了双p,呸，是双拼，多拼的套餐，这也就意味着我可以吃叉烧拼猪脚饭或叉烧拼鸭腿，又或者是烧鹅拼白切鸡饭，当然你还可以选择巨无霸套餐之——叉烧拼猪脚拼鸡腿拼鸭腿拼肥肠拼烧鹅拼白切鸡饭！又名拼多多饭！！！（拼多多看到了请打广告费，谢谢）</p><p>假设要把这样的一个饭店卖烧腊饭的流程用代码实现的话，那么你得首先定义一个烧腊饭的基类Rice，其中定义其基本的方法，比如描述和价格等，而所有种类的烧腊饭将会继承这个基类，并且覆盖这些方法；那么如果你把那些双拼多拼的任意组合都写上去的话，你起码得写上百个子类，这种方式显然不符合软件工程里所推崇的“多用组合，少用继承”的原则；</p><p>所以把上述的方法用一种更加富有弹性的方案来替代，那就是采用装饰器模式来实现；</p></li><li><p><strong>思想</strong></p><p>装饰器模式中，有四大块，分别是:</p><p>基类Component(组件)、基类实现类ConcreteComponent</p><p>抽象装饰类Decorator（装饰）、装饰类实现类ConcreteDecorator</p><p>其中，基类是最顶层的类也就是其它三个的父类，也就是祖宗类（滑稽.jpg），基类实现类和装饰类都是直接继承自基类Component,而我们所要实现的装饰类实现类就是我们的叉烧拼猪脚饭！！！（额…..md饿疯了吧）就是我们所要实现的不同组合；</p><p>以下是装饰器模式的类图：</p><p><img src="https://ws1.sinaimg.cn/large/0062Zwz8gy1fvh0c9z0hrj30q70eumxt.jpg" srcset="/img/loading.gif" alt="img"></p><p>图源：知乎——前端客栈</p></li><li><p><strong>实现</strong></p><p>（1）定义我们的抽象基类Rice（也就是组件），其它的类都是它的子类or孙子类！！！（滑稽.jpg）</p><pre><code class="java">//定义我们的基类Ricepublic abstract class Rice{    public abstract String getDescription();}</code></pre><p>（2）接下来定义我们的具体实现类烧腊饭ShaolaRice（组件的具体实现类）</p><pre><code class="java">public class extend ShaolaRice extends Rice{    @Override    public String getDescription(){        return &quot;饭&quot;;    }}</code></pre><p>（3）定义抽象装饰类——配菜基类</p><pre><code class="java">public abstract class Peicai extends Rice{    //要添加一个基类的引用    protected Rice rice;    @Override    public String getDescription(){        return &quot;&quot;;    }}</code></pre><p>（4）定义装饰类实现类——配菜实现类</p><pre><code class="java">//叉烧public class Chashao extends Peicai{    public Chashao(Rice rice){        this.rice = rice;    }    public String getDesciption(){        //这个判断只是为了在组合时多加个拼字        if(rice.getDescription().length() &gt; 2){            return &quot;叉烧拼&quot;+rice.getDescription();        }        return &quot;叉烧&quot;+rice.getDescription();    }}//烧鸭public class Shaoya extends Peicai{    public Shaoya(Rice rice){        this.rice = rice;    }    public String getDescription(){        //这个判断只是为了在组合时多加个拼字        if(rice.getDescription().length() &gt; 2){            return &quot;烧鸭拼&quot;+rice.getDescription();        }        return &quot;烧鸭&quot;+rice.getDescription();    }}//烧鸡public class Shaoji extends Peicai{    public Shaoji(Rice rice){        this.rice = rice;    }    public String getDescription(){        //这个判断只是为了在组合时多加个拼字        if(rice.getDescription().length() &gt; 2){            return &quot;烧鸡拼&quot;+rice.getDescription();        }        return &quot;烧鸡&quot;+rice.getDescription();    }}//肥肠public class Feichang extends Peicai{    public Feichang(Rice rice){        this.rice = rice;    }    public String getDescription(){        //这个判断只是为了在组合时多加个拼字        if(rice.getDescription().length() &gt; 2){            return &quot;肥肠拼&quot;+rice.getDescription();        }        return &quot;肥肠&quot;+rice.getDescription();    }}//猪脚public class Zhujiao extends Peicai{    public Zhujiao(Rice rice){        this.rice = rice;    }    public String getDescription(){        //这个判断只是为了在组合时多加个拼字        if(rice.getDescription().length() &gt; 2){            return &quot;猪脚拼&quot;+rice.getDescription();        }        return &quot;猪脚&quot;+rice.getDescription();    }}剩下的那些........你懂我意思吧？.jpg</code></pre><p>(5）万事具备，只差筷子了！</p><pre><code class="java">//测试（开吃！！！）public class TestEat {    public static void main(String[] args) {        //老板娘，我要叉烧拼猪脚饭！        Rice shaolaRice = new ShaolaRice();        //给饭上加配菜（装饰）        //写法1        //shaolaRice = new Zhujiao(shaolaRice);        //shaolaRice = new Chashao(shaolaRice);        //写法2：        shaolaRice = new Chashao(new Zhujiao(shaolaRice));        //拼多多套餐饭！        Rice shaolaRice2 = new ShaolaRice();        shaolaRice2 = new Chashao(new Zhujiao(new Shaoya(new Shaoji(new Feichang(shaolaRice2)))));        System.out.println(&quot;哇！&quot;+shaolaRice.getDescription()+&quot;好好味啊！！！&quot;);        System.out.println(&quot;哇！&quot;+shaolaRice2.getDescription()+&quot;好好味啊！！！&quot;);    }}</code></pre><p>测试结果：</p><p><img src="https://ws1.sinaimg.cn/large/0062Zwz8gy1fvh7jwq1ahj30bm01waa4.jpg" srcset="/img/loading.gif" alt="img"></p></li><li><p><strong>总结</strong></p><p><strong>优点：</strong></p><ul><li>装饰器模式的优点在于不用在程序尚未执行的时候就创建大量的类，取而代之的是在程序运行时根据需要动态的组合我们所需要的类；</li><li>扩展性好，就如同上面的例子，哪天老板娘又发明出什么新菜色，像什么烧鹅，鸭腿，兔肉（兔兔那么可爱，你怎么能吃兔兔o(╥﹏╥)o.gif），这时候我们只需要继承装饰类基类，就能完成添加新菜色的任务啦~；</li></ul><p><strong>缺点：</strong></p><ul><li>不易调试，过多的使用装饰器模式会导致系统由许多类似的小的对象组成，会产生大量的装饰者类；</li><li>肚子容易饿……下次举例子千万不要举吃东西的，不说了，写完我就去找老板娘了；</li></ul><p><strong>适用场景：</strong></p><ul><li>为独立的对象动态并透明的添加职责，意思是，不影响其它对象；</li><li>处理能收回的职责；</li><li>当不能通过子类来扩充时。有时候一大堆独立的扩充是可能的，但将激增子类来支持每种扩充间的组合。或者一个类的定义可能被隐藏或不能用于生成子类。</li></ul></li><li><p><strong>应用</strong></p><ul><li>Java中的IO流</li><li>Python中的装饰器语法</li></ul></li><li><p><strong>引用</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/25003369" target="_blank" rel="noopener">设计模式之装饰器模式——前端客栈（知乎）</a></li><li><a href="http://blog.qiji.tech/archives/11823" target="_blank" rel="noopener">[JAVA]设计模式之装饰器模式</a></li><li><a href="http://dreamrunner.org/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3/" target="_blank" rel="noopener">浅谈设计模式三: 装饰器模式(Decorator)</a></li><li><a href="https://blog.csdn.net/android_zyf/article/details/68343953" target="_blank" rel="noopener">Java：一夜一发设计模式（一）——装饰者模式</a></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机类加载机制</title>
    <link href="/2018/09/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2018/09/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Java虚拟机类加载机制"><a href="#Java虚拟机类加载机制" class="headerlink" title="Java虚拟机类加载机制"></a>Java虚拟机类加载机制</h1><blockquote><h3 id="转载-Java虚拟机类加载机制"><a href="#转载-Java虚拟机类加载机制" class="headerlink" title="转载: Java虚拟机类加载机制"></a>转载: <a href="http://blog.csdn.net/u013256816/article/details/50829596" target="_blank" rel="noopener">Java虚拟机类加载机制</a></h3></blockquote><p>看到这个题目，很多人会觉得我写我的java代码，至于类，JVM爱怎么加载就怎么加载，博主有很长一段时间也是这么认为的。随着编程经验的日积月累，越来越感觉到了解虚拟机相关要领的重要性。闲话不多说，老规矩，先来一段代码吊吊胃口。</p><pre><code class="java">public class SSClass{    static    {        System.out.println(&quot;SSClass&quot;);    }}    public class SuperClass extends SSClass{    static    {        System.out.println(&quot;SuperClass init!&quot;);    }    public static int value = 123;    public SuperClass()    {        System.out.println(&quot;init SuperClass&quot;);    }}public class SubClass extends SuperClass{    static    {        System.out.println(&quot;SubClass init&quot;);    }    static int a;    public SubClass()    {        System.out.println(&quot;init SubClass&quot;);    }}public class NotInitialization{    public static void main(String[] args)    {        System.out.println(SubClass.value);    }}/*运行结果：SSClassSuperClass init!123*/</code></pre><p>答案答对了嚒？</p><p>也许有人会疑问：为什么没有输出SubClass init。ok~解释一下：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><p>上面就牵涉到了虚拟机类加载机制。如果有兴趣，可以继续看下去。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示。</p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已HotSpot为基准。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li></ol><p>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>验证阶段大致会完成4个阶段的检验动作：</p><ol><li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行。</li></ol><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p><pre><code class="java">public static int value=123;</code></pre><p>那变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</p><p>至于“特殊情况”是指：public static final int value=123，即当类字段的字段属性是ConstantValue时，会在准备阶段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0.</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备极端，变量已经付过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主管计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程.</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。如下：</p><pre><code class="java">public class Test{    static    {        i=0;        System.out.println(i);//这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）    }    static int i=1;}</code></pre><p>那么去掉报错的那句，改成下面：</p><pre><code class="java">public class Test{    static    {        i=0;        System.out.println(i);//这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）    }    static int i=1;}</code></pre><p>输出结果是什么呢？当然是1啦~在准备阶段我们知道i=0，然后类初始化阶段按照顺序执行，首先执行static块中的i=0,接着执行static赋值操作i=1,最后在main方法中获取i的值为1。</p><p>()方法与实例构造器<code>&lt;init&gt;()</code>方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<code>&lt;init&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法方法已经执行完毕，回到本文开篇的举例代码中，结果会打印输出：SSClass就是这个道理。</p><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p><p><code>&lt;clinit&gt;()</code>方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<code>&lt;clinit&gt;()</code>方法。</p><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。</p><pre><code class="java">package jvm.classload;public class DealLoopTest{    static class DeadLoopClass    {        static        {            if(true)            {                System.out.println(Thread.currentThread()+&quot;init DeadLoopClass&quot;);                while(true)                {                }            }        }    }    public static void main(String[] args)    {        Runnable script = new Runnable(){            public void run()            {                System.out.println(Thread.currentThread()+&quot; start&quot;);                DeadLoopClass dlc = new DeadLoopClass();                System.out.println(Thread.currentThread()+&quot; run over&quot;);            }        };        Thread thread1 = new Thread(script);        Thread thread2 = new Thread(script);        thread1.start();        thread2.start();    }}</code></pre><p>运行结果：（即一条线程在死循环以模拟长时间操作，另一条线程在阻塞等待）</p><pre><code class="java">Thread[Thread-0,5,main] startThread[Thread-1,5,main] startThread[Thread-0,5,main]init DeadLoopClass</code></pre><p>需要注意的是，其他线程虽然会被阻塞，但如果执行()方法的那条线程退出()方法后，其他线程唤醒之后不会再次进入()方法。同一个类加载器下，一个类型只会初始化一次。<br>将上面代码中的静态块替换如下：</p><p>运行结果：</p><pre><code class="java">static{    System.out.println(Thread.currentThread() + &quot;init DeadLoopClass&quot;);    try    {        TimeUnit.SECONDS.sleep(10);    }    catch (InterruptedException e)    {        e.printStackTrace();    }}Thread[Thread-0,5,main] startThread[Thread-1,5,main] startThread[Thread-1,5,main]init DeadLoopClass (之后sleep 10s)Thread[Thread-1,5,main] run overThread[Thread-0,5,main] run over</code></pre><p>虚拟机规范严格规定了有且只有5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ol><li>遇到new,getstatic,putstatic,invokestatic这失调字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li></ol><p>开篇已经举了一个范例：通过子类引用付了的静态字段，不会导致子类初始化。<br>这里再举两个例子。</p><ol><li><p>通过数组定义来引用类，不会触发此类的初始化：（SuperClass类已在本文开篇定义）</p><pre><code class="java">static{    System.out.println(Thread.currentThread() + &quot;init DeadLoopClass&quot;);    try    {        TimeUnit.SECONDS.sleep(10);    }    catch (InterruptedException e)    {        e.printStackTrace();    }}</code></pre></li></ol><p>运行结果：（无）</p><ol><li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化：</p><pre><code class="java">public class ConstClass{    static    {        System.out.println(&quot;ConstClass init!&quot;);    }    public static  final String HELLOWORLD = &quot;hello world&quot;;}public class NotInitialization{    public static void main(String[] args)    {        System.out.println(ConstClass.HELLOWORLD);    }}</code></pre></li></ol><p>运行结果：hello world</p><p>附：昨天从论坛上看到一个例子，很有意思，如下：</p><pre><code class="java">package jvm.classload;public class StaticTest{    public static void main(String[] args)    {        staticFunction();    }    static StaticTest st = new StaticTest();    static    {        System.out.println(&quot;1&quot;);    }    {        System.out.println(&quot;2&quot;);    }    StaticTest()    {        System.out.println(&quot;3&quot;);        System.out.println(&quot;a=&quot;+a+&quot;,b=&quot;+b);    }    public static void staticFunction(){        System.out.println(&quot;4&quot;);    }    int a=110;    static int b =112;}</code></pre><p>问题是：请问输出是什么？</p>]]></content>
    
    
    <categories>
      
      <category>JVM虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cron表达式</title>
    <link href="/2018/09/20/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2018/09/20/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h2><p><strong>转载：</strong><a href="https://www.cnblogs.com/javahr/p/8318728.html" target="_blank" rel="noopener">Cron表达式</a></p><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>Cron表达式是一个字符串，字符串以 5——6个空格隔开，分为6或7个域，每一个域代表一个含义</p><p>有以下两种表达格式：</p><p>　　（1） Seconds Minutes Hours DayofMonth Month DayofWeek Year</p><p>　　（2）Seconds Minutes Hours DayofMonth Month DayofWeek</p><h3 id="一、结构"><a href="#一、结构" class="headerlink" title="一、结构"></a>一、结构</h3><p>corn从左到右（用空格隔开）：秒 分 小时 月份 星期中的日期 年份</p><h3 id="二、各字段之间的含义"><a href="#二、各字段之间的含义" class="headerlink" title="二、各字段之间的含义"></a>二、各字段之间的含义</h3><table><thead><tr><th>字段</th><th>允许值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒（Seconds）</td><td>0~59的整数</td><td>, - * / 四个字符</td></tr><tr><td>分（<em>Minutes</em>）</td><td>0~59的整数</td><td>, - * / 四个字符</td></tr><tr><td>小时（<em>Hours</em>）</td><td>0~23的整数</td><td>, - * / 四个字符</td></tr><tr><td>日期（<em>DayofMonth</em>）</td><td>1~31的整数（但是你需要考虑你月的天数）</td><td>,- * ? / L W C 八个字符</td></tr><tr><td>月份（<em>Month</em>）</td><td>1~12的整数或者 JAN-DEC</td><td>, - * / 四个字符</td></tr><tr><td>星期（<em>DayofWeek</em>）</td><td>1~7的整数或者 SUN-SAT （1=SUN）</td><td>, - * ? / L C # 八个字符</td></tr><tr><td>年(可选，留空)（<em>Year</em>）</td><td>1970~2099</td><td>, - * / 四个字符</td></tr></tbody></table><p>每一个域都使用数字，但还可以出现如下特殊字符，他们的含义是：</p><p>（1） <em>：表示匹配该域的任意值；假如在Minutes域使用</em> ，即表示每分钟都会触发事件；</p><p>（2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 <em>? ， 其中最后一位只能用？，而不能使用</em> ，如果使用 * 表示不管星期几都会触发，实际上并不是这样。</p><p>（3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次</p><p>（4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次.</p><p>（5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。</p><p>（6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。</p><p>（7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，<strong>W的最近寻找不会跨过月份</strong> 。</p><p>（8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。</p><p>（9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。</p><h3 id="三、常用表达式例子"><a href="#三、常用表达式例子" class="headerlink" title="三、常用表达式例子"></a>三、常用表达式例子</h3><p>　　（1）<strong>0 0 2 1 * ? *</strong> 表示在每月的1日的凌晨2点调整任务</p><p>　　（2）<strong>0 15 10 ? * MON-FRI</strong> 表示周一到周五每天上午10:15执行作业</p><p>　　（3）<strong>0 15 10 ? 6L 2002-2006</strong> 表示2002-2006年的每个月的最后一个星期五上午10:15执行作</p><p>　　（4）<strong>0 0 10,14,16 * * ?</strong> 每天上午10点，下午2点，4点</p><p>　　（5）<strong>0 0/30 9-17 * * ?</strong> 朝九晚五工作时间内每半小时</p><p>　　（6）<strong>0 0 12 ? * WED</strong> 表示每个星期三中午12点</p><p>　　（7）<strong>0 0 12 * * ?</strong> 每天中午12点触发</p><p>　　（8）<strong>0 15 10 ? * *</strong> 每天上午10:15触发</p><p>　　（9）<strong>0 15 10 * * ?</strong> 每天上午10:15触发</p><p>　　（10）<strong>0 15 10 * ?</strong> 每天上午10:15触发</p><p>　　（11）<strong>0 15 10 * * ? 2005</strong> 2005年的每天上午10:15触发</p><p>　　（12）<strong>0 * 14 ?</strong> 在每天下午2点到下午2:59期间的每1分钟触发</p><p>　　（13）<strong>0 0/5 14 * * ?</strong> 在每天下午2点到下午2:55期间的每5分钟触发</p><p>　　（14）<strong>0 0/5 14,18 * * ?</strong> 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</p><p>　　（15）<strong>0 0-5 14 * * ?</strong> 在每天下午2点到下午2:05期间的每1分钟触发</p><p>　　（16）<strong>0 10,44 14 ? 3 WED</strong> 每年三月的星期三的下午2:10和2:44触发</p><p>　　（17）<strong>0 15 10 ? * MON-FRI</strong> 周一至周五的上午10:15触发</p><p>　　（18）<strong>0 15 10 15 * ?</strong> 每月15日上午10:15触发</p><p>　　（19）<strong>0 15 10 L * ?</strong> 每月最后一日的上午10:15触发</p><p>　　（20）<strong>0 15 10 ? * 6L</strong> 每月的最后一个星期五上午10:15触发</p><p>　　（21）<strong>0 15 10 ? * 6L 2002-2005</strong> 2002年至2005年的每月的最后一个星期五上午10:15触发</p><p>　　（22）<strong>0 15 10 ? * 6#3</strong> 每月的第三个星期五上午10:15触发</p><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>　　（1）有些子表达式能包含一些范围或列表</p><p>　　例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”</p><p>“*”字符代表所有可能的值</p><p>　　因此，“ <em>” 在子表达式（月）里表示每个月的含义，“</em> ” 在子表达式（天（星期））表示星期的每一天</p><p>　　“ / ”字符用来指定数值的增量<br>　　例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟<br>在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样</p><p>　　“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值<br>　　当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”</p><p>　　“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写<br>　　但是它在两个子表达式里的含义是不同的。<br>　　在天（月）子表达式中，“L”表示一个月的最后一天<br>　　在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT</p><p>　　如果在“L”前有具体的内容，它就具有其他的含义了</p><p>　　例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五<br>　　注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>]]></content>
    
    
    <categories>
      
      <category>工具字典</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具字典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>informix时间函数</title>
    <link href="/2018/09/20/Informix%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0/"/>
    <url>/2018/09/20/Informix%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Informix时间函数"><a href="#Informix时间函数" class="headerlink" title="Informix时间函数"></a>Informix时间函数</h1><h2 id="转载：Informix时间函数"><a href="#转载：Informix时间函数" class="headerlink" title="转载：Informix时间函数"></a>转载：<a href="https://blog.csdn.net/u012895467/article/details/21173547" target="_blank" rel="noopener">Informix时间函数</a></h2><h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><ul><li><p>DATE</p><ul><li><p>DATE(VARCHAR(10))返回DATE类型</p><p>该函数以一个字符串变量为参数，其格式由环境变量 DBDATE 指定，并返回一个 DATE 类型。US English 地区的缺省格式是“MDY4/”。</p></li><li><p>DATE(DATETIME) 返回 DATE 类型</p><p>这个函数与上一个函数相同，但是其输入参数是可以为任意精度的 DATETIME。</p></li><li><p>DATE(INTEGER) 返回 DATE 类型</p><p>INTEGER 参数表示从 1899 年 12 月 31 日以来的天数。</p></li></ul></li><li><p>DAY</p><ul><li><p>DAY(DATE) 返回 INTEGER 类型</p><p>DAY 函数返回月中的日，格式为 INTEGER。</p></li><li><p>DAY(DATETIME) 返回 INTEGER 类型</p><p>与上一个函数相同，只是这个函数的输入参数为任意精度的 DATETIME。</p></li></ul></li><li><p>EXTEND</p><ul><li><p>EXTEND(DATE, precision) 返回 DATETIME 类型</p><p>EXTEND 函数调整 DATE 参数的精度，并返回适当的 DATETIME。由于说起来有点儿模糊，这里举一个例子： EXTEND(DATE(1), YEAR TO SECOND)</p></li><li><p>EXTEND(DATETIME, precision) 返回 DATETIME 类型 与上一个函数相同，但操作的对象是一个 DATETIME，而不是一个 DATE。</p></li></ul></li><li><p>MONTH</p><ul><li><p>MONTH(DATE) 返回 INTEGER 类型</p><p>MONTH 从参数 DATE 中提取出月份。</p></li><li><p>MONTH(DATETIME) 返回 INTEGER 类型</p><p>该函数从任意精度的 DATETIME 中提取出月份。</p></li></ul></li><li><p>WEEKDAY</p><ul><li><p>WEEKDAY(DATE) 返回 INTEGER 类型</p><p>WEEKDAY 函数根据指定的 DATE 返回一个 INTEGER，表示星期几。0 表示星期天，6 表示星期六。</p></li><li><p>WEEKDAY(DATETIME) 返回 INTEGER 类型</p><p>与上一个函数相同，但操作对象是 DATETIME。</p></li></ul></li><li><p>YEAR</p><ul><li><p>YEAR(DATE) 返回 INTEGER 类型</p><p>该函数从指定的参数 DATE 中提取出年份。</p></li><li><p>YEAR(DATETIME) 返回 INTEGER 类型</p><p>与上一个函数相同，但操作对象是 DATETIME。</p></li></ul></li><li><p>MDY</p><ul><li><p>MDY(INTEGER, INTEGER, INTEGER) 返回 DATE 类型</p><p>该函数根据三个 INTEGER 参数创建一个 DATE。这些参数分别指定月、日和年。注意，年是四位的整数。</p></li></ul></li><li><p>TO_CHAR</p><ul><li><p>TO_CHAR(DATE, VARCHAR(??)) 返回 VARCHAR(??) 类型</p><p>该函数带一个 DATE 参数和一个格式参数，并返回一个表示日期的字符串，该字符串遵从要求的格式。格式字符串可以包括：</p><p>%A: 周<br>%B: 月<br>%d: 十进制表示的日<br>%Y: 4 位数表示的年<br>%R: 按 24 小时计的时间</p></li><li><p>TO_CHAR(DATE, VARCHAR(??)) 返回 VARCHAR(??) 类型</p><p>同上。</p></li><li><p>TO_DATE(VARCHAR(??), VARCHAR(??)) 返回 DATE 类型</p><p>这是 TO_CHAR 的逆向操作，使用相同的格式字符串作为第二个参数</p></li></ul></li></ul><h3 id="informix数据库中的时间运算"><a href="#informix数据库中的时间运算" class="headerlink" title="informix数据库中的时间运算"></a>informix数据库中的时间运算</h3><p>下面的语句中extend用来限制到年、月、日，interval是说明间隔数减去（加上）天数，interval最多取两位</p><p>###ep：</p><ul><li>从time_stamp字段减去两天时间<br>select extend(time_stamp-interval(2) day to day) from users;</li><li>从当前时间减去两天<br>select extend(current-interval(2) day to day) from users;<br>减去（加上）月数，interval最多取两位</li><li>从time_stamp字段减去两个月<br>select extend(time_stamp-interval(2) month to month) from users;</li><li>从当前时间减去两个月<br>select extend(current-interval(2) month to month) from users;<br>减去（加上）年数，interval最多取四位</li><li>从time_stamp字段减去两个年<br>select extend(time_stamp-interval(2) year to year) from users;</li><li>从当前时间减去两年<br>select extend(current-interval(2) year to year) from users;<br>试了一下，上面的写法会显示到毫秒，如<br>2004-09-11 17:24:03.000<br>2004-09-11 17:24:03.000<br>2004-09-11 17:24:03.000<br>可以再加个extend限制，如下<br>显示到月<br>select extend(((extend(current-interval(2) day to day))),year to month) from users;<br>显示到天<br>select extend(((extend(current-interval(2) month to month))),year to day) from users;<br>显示到秒<br>select extend(((extend(current-interval(2) year to year))),year to second) from users;<br>上面讲的是其中一种方法，今天又学到一种，可以用units关键字。<br>–年<br>select current-5 units year from users<br>–月<br>select current-5 units month from users<br>–日<br>select current-5 units day from users<br>–时<br>select current-5 units hour from users<br>–分<br>select current-5 units minute from users<br>–秒<br>select current-5 units second from users</li></ul><h3 id="几种时间"><a href="#几种时间" class="headerlink" title="几种时间:"></a>几种时间:</h3><p>select today+1-MDY(1,1,YEAR(today)) from your_table – day of year<br>select TRUNC((today+6-MDY(1,1,YEAR(today))-WEEKDAY(today))/7,0)+1 your_table – week of year<br>SELECT TODAY - DAY(TODAY) AS LDOLM FROM your_table – last_day_of_last_month<br>SELECT LDOLM - DAY(LDOLM) + 1 AS FDOLM FROM your_table – first_day_of_last_month<br>SELECT (TODAY - DAY(TODAY)) - DAY(TODAY - DAY(TODAY)) + 1 AS FDOLM FROM your_table<br>SELECT ((TODAY) + 1 UNITS MONTH - (DAY(TODAY)) UNITS DAY) FROM your_table – last_day_of_month<br>select TODAY - DAY(TODAY) + 1 UNITS DAY from your_table – first day of month<br>select MDY(1,1,YEAR(_date)) from your_table – first day of year</p>]]></content>
    
    
    <categories>
      
      <category>工具字典</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具字典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计五大原则</title>
    <link href="/2018/09/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2018/09/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象设计五大原则"><a href="#面向对象设计五大原则" class="headerlink" title="面向对象设计五大原则"></a>面向对象设计五大原则</h2><p>谨记：“SOLID”</p><ol><li><p><strong>Single Responsibility Principle——单一职责原则</strong></p><p>思想：一个类应该只有一个引起它变化的原因；</p></li></ol><ol start="2"><li><p><strong>Open Closed Principle——开放封闭原则</strong></p><p>思想：对扩展开放，对修改封闭；</p><p>如何在不修改类的源代码，通过添加新代码来增强现有类的行为？</p><p>答;通过 抽象(Interface和抽象基类)实现OCP的核心思想就是对抽象编程，让类依赖于固定的抽象，对修改就是封闭的；而通过面向丢下的继承和多态机制，通过覆写方法改变固有行为，实现新的扩展方法，对于扩展就是开放的；</p></li><li><p><strong>Liskov Subsitution Principle——里氏替换原则</strong></p><p>思想：子类必须能替换掉它的父类型；</p></li><li><p><strong>InterFace Segregation Principle——接口隔离原则</strong></p><p>思想：使用多个小的专门的接口，而不要都是用一个大的总接口；</p></li><li><p><strong>Dependency Inversion Principle——依赖倒置原则</strong></p><p>思想：高层模块不应该依赖底层模块，两者都应该抽象，抽象不应该依赖细节，细节应该依赖于抽象</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
